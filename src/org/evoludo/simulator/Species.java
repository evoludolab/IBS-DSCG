//
// EvoLudo Project
//
// Copyright 2010 Christoph Hauert
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// For publications in any form, you are kindly requested to attribute the
// author and project as follows:
//
//	Hauert, Christoph (<year>) EvoLudo Project, http://www.evoludo.org
//			(doi: <doi>[, <version>])
//
//	<doi>:	digital object identifier of the downloaded release (or the
//			most recent release if downloaded from github.com),
//	<year>:	year of release (or download), and
//	[, <version>]: optional version number (as reported in output header
//			or GUI console) to simplify replication of reported results.
//
// The formatting may be adjusted to comply with publisher requirements.
//

package org.evoludo.simulator;

import java.io.PrintStream;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;

//import org.evoludo.simulator.models.ODEEuler.ODEDelegate;
//import org.evoludo.simulator.models.ODERungeKutta;
//import org.evoludo.simulator.models.PDEReactionDiffusion;
//import org.evoludo.simulator.models.PDEReactionDiffusion.PDEDelegate;
//import org.evoludo.simulator.models.SDEEuler;
//import org.evoludo.simulator.models.SDEEuler.SDEDelegate;
import org.evoludo.util.CLOParser;
import org.evoludo.util.CLOProvider;
import org.evoludo.util.CLOption;
import org.evoludo.util.CLOption.CLODelegate;
import org.evoludo.util.Formatter;
import org.evoludo.util.Combinatorics;
import org.evoludo.util.RNGDistribution;

/**
 * @author Christoph Hauert
 *
 */
public abstract class Species implements Model.IBS, CLOProvider {

	public interface IBSDelegate extends ModelDelegate {

		/**
		 * 
		 * @return
		 */
		public boolean isModelType(Model.Type type);

		/**
		 * 
		 * @return
		 */
		public boolean setModelType(Model.Type type);
	}

	protected Species(EvoLudo engine, String key) {
		this.engine = engine;
		logger = engine.getLogger();
		KEY = key;
		// awkward (but inconsequential) cast - add in Population constructor instead
		// engine.addGame((Population)this);
	}

	protected Species(Population partner) {
		KEY = partner.getKey();
		addSpecies(partner);
	}

	public void debugCheck(String info) {
		throw new Error("override for debugging");
	}

	/**
	 * Returns brief description of the active model, including title, author and
	 * version. For example, 2x2 games in {@link org.evoludo.simulator.lab.TwoByTwo}
	 * return "Title: 2x2 Games\nAuthor: Christoph Hauert\nTime evolution of
	 * cooperators and defectors in different population structures."
	 * <p>
	 * <strong>Note:</strong> newline characters, '\n', are acceptable in String returned. If
	 * necessary they will be replaced by {@literal <br/>
	 * } e.g. for ePub's. Do not use HTML formatting in info string.
	 * 
	 * @return description of active model
	 */
	public abstract String getInfo();

	/**
	 * Returns title of active model, e.g. 2x2 games in
	 * {@link org.evoludo.simulator.lab.TwoByTwo} returns "2x2 Games".
	 * 
	 * @return title of active model
	 */
	public abstract String getTitle();

	/**
	 * Indicates whether models are running in a web browser (or ePub) using
	 * javascript generated by GWT or as a java application. Special characters in
	 * strings can result in headaches when running in an ePub (or, worse still, in
	 * XHTML pages). Mostly used to change string formatting for the two scenarios.
	 */
	public static boolean isGWT = false;

	/**
	 * Running simulations are halted when <code>generation &ge; nGenerations</code>
	 * holds for the first time. This is useful to indicate the end of simulations
	 * or to generate (graphical) snapshots in the GUI after a specified amount of
	 * time has elapsed.
	 * <p>
	 * <strong>Note:</strong> {@link #nGenerations} is set with the command line option
	 * <code>--generations</code> (or <code>-g</code>), see {@link #cloGenerations}.
	 */
	protected double nGenerations;

	public double getNGenerations() {
		return nGenerations;
	}

	/**
	 * Death-birth process: include focal individual in competition to re-populate
	 * focal site. This corresponds to the 'imitation' update in the bck-rule
	 * (Ohtsuki et al. Nature, 2005). In the original Moran process offspring can
	 * replace their parent. In well-mixed populations the difference is negligible
	 * (of <code>o(1/N)</code>) but can be significant in structured populations.
	 * <p>
	 * <strong>Note:</strong> currently hard coded and not configurable.
	 */
//XXX add option to --popupdate to include/exclude self for moran processes? (imitation for death-birth, original moran
//	  for birth-death
	protected boolean deathBirthIncludeSelf = false;

	private final String KEY;

	/**
	 * Returns identifier of the active model, e.g. 2x2 games in
	 * {@link org.evoludo.simulator.lab.TwoByTwo} return "2x2". This corresponds to
	 * the argument for the <code>--game</code> option to load a particular model.
	 * 
	 * @return identifying key of model
	 */
	public String getKey() {
		return KEY;
	}

	/**
	 * Load simulation framework.
	 * <p>
	 * <strong>Note:</strong> engine must be set before calling load
	 */
	public void load() {
		if (isLoaded)
			return;
		rng = engine.getRNG();
		isLoaded = true;
	}

	/**
	 * <code>true</code> if simulation framework has been loaded.
	 */
	protected boolean isLoaded = false;

	/**
	 * Unload simulation framework. Opportunity to free up resources
	 */
	public void unload() {
		if (isLoaded) {
			// all entries in species need to be unloaded without creating loops
			// only the species which received the call to unload will execute this part
			isLoaded = false;
			for (Population pop : species) {
				if (pop.isLoaded) {
					// species needs to be unloaded - clear isLoaded to prevent loops
					pop.isLoaded = false;
					pop.unload();
				}
			}
			// all species have been unloaded - clear list
			species.clear();
		}
		distrMutation = null;
		rng = null;
	}

	/**
	 * override to provide custom implementation of PDE model
	 */
//	public Model.ODE createODE() {
//		return new ODERungeKutta((ODEDelegate)this);
//	}

	/**
	 * override to provide custom implementation of PDE model
	 */
//	public Model.SDE createSDE() {
//		return new SDEEuler((SDEDelegate)this, rng);
//	}

	/**
	 * override to provide custom implementation of PDE model
	 */
//	public Model.PDE createPDE() {
//		return new PDEReactionDiffusion((PDEDelegate)this, engine.hirePDESupervisor());
//	}

	@Override
	public void setSpecies(ArrayList<Population> species) {
//XXX eventually this should be part of IBS to set the game
	}

	/**
	 * Simulation results are written here. Ignored by GWT and JRE GUI. Defaults to
	 * <code>stdout</code> in JRE.
	 * <p>
	 * <strong>Note:</strong> <code>output</code> can be customized using the
	 * <code>--output</code> and <code>--append</code> command line options (see
	 * {@link EvoLudoJRE#cloOutput} and {@link EvoLudoJRE#cloAppend}, respectively.
	 */
	protected PrintStream out = System.out;

	public void setOutput(PrintStream output) {
		this.out = (output == null?System.out:output);
	}

	/**
	 * Interface with the outside world. Deals with command line options, help,
	 * encoding/restoring state, logging, printing of result, etc. Two
	 * implementations, one for JRE and one for GWT, because input/output routines
	 * differ.
	 */
	protected EvoLudo engine;

	/**
	 * @return returns engine assigned to population.
	 */
	public EvoLudo getEngine() {
		return engine;
	}

	/**
	 * Convenience method for xDEDelegates.
	 * 
	 * @return <code>true</code> if active model is of type <code>type</code>
	 */
	@Override
	public boolean isModelType(Type type) {
//XXX this causes loops for IBS because species is both the model and the game...
//		return engine.getModel().isModelType(type);
		Model model = engine.getModel();
		if (model == this)
			return type==Model.Type.IBS;
		return model.isModelType(type);
	}

	/**
	 * Convenience method for xDEDelegates.
	 * 
	 * return <code>true</code> if model type changed
	 */
	public boolean setModelType(Type type) {
		return engine.setModelType(type);
	}

	/**
	 * <code>true</code> for models involving multiple species
	 */
	public boolean isMultispecies = false;

	/**
	 * Type of species update (multi-species models only).
	 */
	public SpeciesUpdateType speciesUpdateType = SpeciesUpdateType.SIZE;

	/**
	 * Types of species updates (only relevant for multi-species models):
	 * <dl>
	 * <dt>size</dt>
	 * <dd>focal species selected proportional to their size</dd>
	 * <dt>fitness</dt>
	 * <dd>focal species selected proportional to their total fitness</dd>
	 * <dt>turns</dt>
	 * <dd>one species is selected after another.</dd>
	 * </dl>
	 * For <b>size</b> and <b>fitness</b> selection is also proportional to the
	 * update rate (see {@link Population#speciesUpdateRate}) of each species.
	 */
	public static enum SpeciesUpdateType implements CLOption.KeyCollection {
		SIZE("size", "pick species based on size"),
		FITNESS("fitness", "pick species based on fitness"), 
		TURNS("turns", "pick one species after another");

		String key;
		String title;

		SpeciesUpdateType(String key, String title) {
			this.key = key;
			this.title = title;
		}

		static SpeciesUpdateType parse(String arg) {
			for (SpeciesUpdateType sut : values())
				if (sut.key.startsWith(arg))
					return sut;
			return null;
		}

		@Override
		public String toString() {
			return key+": "+title;
		}

		@Override
		public String getKey() {
			return key;
		}

		@Override
		public String getTitle() {
			return title;
		}

		@Override
		public CLOption.KeyCollection[] getKeys() {
			return values();
		}
	}

	/**
	 * Set species update to <code>type</code>.
	 * 
	 * @param type update type of species
	 */
	public void setSpeciesUpdateType(SpeciesUpdateType type) {
		speciesUpdateType = type;
	}

	/**
	 * @return species update type.
	 */
	public SpeciesUpdateType getSpeciesUpdateType() {
		return speciesUpdateType;
	}

	/**
	 * @return species update rates.
	 */
	public double[] getSpeciesUpdateRates() {
		double[] rates = new double[getNSpecies()];
		int idx = 0;
		for (Population pop : species)
			rates[idx++] = pop.getSpeciesUpdateRate();
		return rates;
	}

	/**
	 * Indicates current mode of IBS model
	 */
	protected Mode mode = Mode.DYNAMICS;

	@Override
	public boolean setMode(Mode mode) {
		boolean newmode = (this.mode != mode);
		if (!newmode || !permitsMode(mode))
			return false;
		this.mode = mode;
		return newmode;
	}

	@Override
	public Mode getMode() {
		return mode;
	}

	/**
	 * <code>true</code> if new sample for statistics should be started
	 * ({@link #modelInit()} will be called on next update).
	 */
	protected boolean statisticsSampleNew = false;

	/**
	 * EXPERIMENTAL: container for fixation data; should probably become more
	 * generic structure
	 */
	protected FixationData fixData = null;

	/**
	 * EXPERIMENTAL: should mature into data structure useful for statistics
	 */
	public class FixationData {
		public int initialNode = -1;
		public int typeFixed = -1;
		public double updatesFixed = -1.0;
		public double timeFixed = -1.0;
		public boolean probRead = true;
		public boolean timeRead = true;

		public void reset() {
			initialNode = -1;
			probRead = true;
			timeRead = true;
		}

		@Override
		public String toString() {
			return "{ initialNode -> " + initialNode + ", typeFixed -> " + typeFixed + ", updatesFixed -> "
					+ Formatter.format(updatesFixed, 6) + ", timeFixed -> " + Formatter.format(timeFixed, 6)
					+ ", probRead -> " + probRead + ", timeRead -> " + timeRead + " }";
		}
	}

	/**
	 * Number of statistics samples collected
	 */
	protected int nStatisticsSamples = 0;

	/**
	 * @return number of samples collected
	 */
	public int getNStatisticsSamples() {
		return nStatisticsSamples;
	}

	/**
	 * Opportunity to collect statistics
	 */
	@Override
	public void readStatisticsSample() {
		nStatisticsSamples++;
		statisticsSampleNew = true;		
	}

	@Override
	public void initStatisticsSample() {
		statisticsSampleNew = false;		
	}

	/**
	 * @return fixation data for statistics
	 */
	public FixationData getFixationData() {
		return fixData;
	}

	/**
	 * Part of ODE/PDEDelegate implementation
	 *
	 * @return logger for notifications
	 */
	public Logger getLogger() {
		return logger;
	}

	public void initDerivatives() {
		if (species.size()>1) {
			// allocate some memory for calculating derivatives in inter-species interactions
			int maxTraits = 0;
			for( Population pop : species )
				maxTraits = Math.max(maxTraits, pop.getNTraits());
			if( pyt==null || pyt.length!=maxTraits ) {
				pyt = new double[maxTraits];
				pft = new double[maxTraits];
				pdyt = new double[maxTraits];
			}
		}
	}

	public final double[] modelDerivatives(double t, double[] yt, double[] ft, double[] dyt, double[] scorescratch) {
//		if( isMultispecies ) {
// note isMultispecies is set in DE model but not here...
		if( species.size()>1 ) {
			int skipTraits = 0;
			for (Population pop : species) {
				int nTraits = pop.getNTraits();
				System.arraycopy(yt, skipTraits, pyt, 0, nTraits);
				pop.getDerivatives(t, pyt, pft, pdyt, scorescratch);
				System.arraycopy(pft, 0, ft, skipTraits, nTraits);
				System.arraycopy(pdyt, 0, dyt, skipTraits, nTraits);
				skipTraits += nTraits;
			}
			return dyt;
		}
		return getDerivatives(t, yt, ft, dyt, scorescratch);
	}

	/**
	 * @param t
	 * @param yt
	 * @param ft
	 * @param dyt
	 * @param scorescratch
	 * @return
	 */
	public abstract double[] getDerivatives(double t, double[] yt, double[] ft, double[] dyt, double[] scorescratch);

	double[] pyt, pft, pdyt;
	protected int deOffset = 0;

	/**
	 * ODE model: implements Euler or Runge-Kutta integration schemes.
	 */
//	@Deprecated
//	protected Model.ODE ode;

	/**
	 * SDE model: implements Euler integration stochastic noise.
	 */
//	@Deprecated
//	protected Model.SDE sde;

	/**
	 * PDE model: implements reaction-diffusion integration
	 */
//	@Deprecated
//	protected Model.PDE pde;

	/**
	 * <code>true</code> if optimizations for Moran process requested.
	 * <p>
	 * <strong>Note:</strong>
	 * <ul>
	 * <li>optimizations can be requested with the command line option
	 * <code>--optimize</code> (or <code>-1</code>), see {@link #cloOptimize}.</li>
	 * <li>currently restricted to discrete strategies where Moran type processes
	 * can be optimized in structured populations by skipping events involving
	 * individuals of the same type (see {@link DPopulation}).</li>
	 * </ul>
	 */
	protected boolean optimizeMoran = false;

	/**
	 * <code>true</code> if optimizations for homogeneous populations requested.
	 * <p>
	 * <strong>Note:</strong>
	 * <ul>
	 * <li>optimizations can be requested with the command line option
	 * <code>--optimize</code> (or <code>-1</code>), see {@link #cloOptimize}.</li>
	 * <li>currently restricted to discrete strategies where homogeneous population
	 * states can be skipped by deterministically introducing new mutant after an
	 * geometrically (exponentially) distributed waiting time (see
	 * {@link DPopulation}).</li>
	 * </ul>
	 */
	protected boolean optimizeHomo = false;

	/**
	 * Geometric (exponential) waiting time distribution for optimizations of
	 * homogeneous populations
	 */
	protected RNGDistribution.Geometric distrMutation;

	/**
	 * <code>true</code> is population update is synchronous
	 */
	protected boolean isSynchronous;

	/**
	 * Keeps track of the number of generations that have elapsed. in a population
	 * of size <code>N</code> one generation corresponds to <code>N</code> updates,
	 * which translates to <code>N</code> events (birth, death, imitation, etc.).
	 * <p>
	 * <strong>Note:</strong> generally differs from 'real time' (see
	 * {@link Species#realtime}). <code>generation=0</code> at the beginning of a
	 * simulation run. <code>generation</code> is incremented <i>before</i> the next
	 * event is processed, to reflect the time at which the event occurs.
	 */
	protected double generation = -1.0;

	/**
	 * Keeps track of the elapsed time, taking into account the fitness of the
	 * population. For example, less time passes between reproductive events in
	 * populations with high fitness.
	 * <p>
	 * <strong>Note:</strong> requires non-negative individual scores.
	 */
	protected double realtime = -1.0;

	/**
	 * Indicates the frequency (measured in generations) with which simulations
	 * report updates on their current state. for example, the GUI gets updated
	 * whenever <code>reportFreq</code> generations (or fractions thereof) have
	 * elapsed.
	 * <p>
	 * <strong>Note:</strong> <code>reportFreq&lt;0</code> disables reporting;
	 * <code>reportFreq=0</code> reports every single update.
	 */
	protected double reportFreq = 1.0;

	/**
	 * Probability of mutations, i.e. change of type/strategy e.g. during a
	 * reproduction event or when attempting to imitate the type/strategy of another
	 * individual. The implementation of mutations depends on the model type. In
	 * particular whether types/strategies are discrete or continuous.
	 */
	protected double pMutation = -1.0;

	@Override
	public String getStatus() {
		if (isMultispecies) {
			String status = "";
			for( Population pop : species) 
				status += (status.length()>0?"<br/><i>":"<i>")+pop.getName()+":</i> "+pop._getStatus();
			return status;
		}
		return _getStatus();
	}

	/**
	 * @return status of population
	 */
	protected abstract String _getStatus();

	@Override
	public String getCounter() {
		return "time: " + Formatter.format(getTime(), 2) + " ("
						+ Formatter.format(getRealtime(), 2) + ")";
	}

	/**
	 * <strong>Note:</strong> should be overridden by model implementations but should always
	 * include revision information.
	 * 
	 * @return returns engine version (based on <code>git describe --tags</code>) to
	 *         identify the code revision for reproducibility.
	 *
	 */
	public String getVersion() {
		return engine.getVersion();
	}

	/**
	 *
	 */
	protected boolean verbose = false; // debugging, dumping to logger

	/**
	 * @return time elapsed (measured in generations, i.e. in number of updates divided 
	 * 		   by population size; same as Monte-Carlo steps).
	 */
	@Override
	public double getTime() {
		return generation;
	}

	/**
	 * @return time elapsed (measured in update rates, i.e. inversely proportional
	 *         to the total fitness of the population(s)).
	 */
	public double getRealtime() {
		return realtime;
	}

	/**
	 * Utility routine to set generations and time when restoring an archived state.
	 * 
	 * @param updates
	 * @param time
	 * @return true if restore succeeded
	 */
	public boolean restoreTime(double updates, double time) {
		for( Population pop : species) {
			pop.realtime = time;
			pop.generation = updates;
		}
		return true;
	}

	/**
	 * List with all species in model including this one. list should be shared with
	 * other populations (to simplify bookkeeping) but the species list CANNOT be
	 * static! otherwise it is impossible to run multiple instances of models/games
	 * concurrently
	 */
	protected ArrayList<Population> species;

	/**
	 * Add <b>population</b> to list of species. duplicate entries are ignored.
	 * allocate new list if necessary. share relevant quantities with 'fellow'
	 * population (species list, random number generator, engine and listeners).
	 *
	 * @param population to add to species list.
	 * @return <code>true</code> if <b>population</b> successfully added;
	 *         <code>false</code> if it is already part included in list.
	 */
	public boolean addSpecies(Population population) {
		if (species == null)
			species = new ArrayList<Population>();
		// do not add duplicates
		if (species.contains(population))
			return false;
		if (!species.add(population))
			return false;
		if (species.size() == 1)
			return true;
		// multi-species interaction; the different species need to share a few
		// quantities (too early to share models)
		population.species = species;
		population.rng = rng;
		population.engine = engine;
		population.logger = logger;
		return true;
	}

	/**
	 * @param population remove from list of species.
	 * @return <code>true</code> if species contained <b>population</b>.
	 */
	public boolean removeSpecies(Population population) {
		if (species == null)
			return false;
		return species.remove(population);
	}

	/**
	 * @return number of species in list.
	 */
	public int getNSpecies() {
		if (species == null)
			return 0;
		return species.size();
	}

	/**
	 * @return list of species
	 */
	public ArrayList<Population> getSpecies() {
		return species;
	}

	/**
	 * @param idx index of species to retrieve from list.
	 * @return species with index <b>idx</b> in species list.
	 */
	public Population getSpecies(int idx) {
		if (species == null)
			return null;
		return species.get(idx);
	}

	@Override
	public void init() {
		// reset time
		generation = 0.0;
		realtime = 0.0;
		nGenerationsHit = false;
	}

	/**
	 * Reset this population
	 */
	@Override
	public void reset() {
		if (fixData != null)
			fixData.reset();
		nStatisticsSamples = 0;

		// with optimization, homogeneous populations do not wait for next mutation
		if (optimizeHomo) {
			// NOTE: pMutation can still be 0, in that case we will just reset the
			// generation count (alternatively could be set to infinity
			// but that is even less informative)
			if (pMutation <= 0.0)
				distrMutation = null;
			else {
				if (distrMutation == null)
					distrMutation = new RNGDistribution.Geometric(rng.getRNG(), pMutation);
				else
					distrMutation.setProbability(pMutation);
			}
		}
		nextSpeciesIdx = -1;
	}

	private boolean nGenerationsHit;

	@Override
	public boolean next() {
		// start new statistics sample if required
		if (isMode(Mode.STATISTICS) && statisticsSampleNew) {
			engine.modelInit();
			engine.modelUpdate();
			// debugCheck("modelNext (new sample)");
		} else if (engine.modelConverged()) {
			// debugCheck("modelNext (converged)");
			if (!optimizeHomo) {
				engine.fireModelStopped();
				return false;
			}
			engine.fireModelRunning();
			// optimize waiting time in homogeneous states by advancing time and
			// deterministically introduce new mutant
			// Note: optimizeHomo currently requires that mutation rates and update rates in
			// all species are equal (see checkParams)
			// so we can simply use the distribution for this species
			// optimizeHomo also requires that pMutation is small (otherwise this
			// optimization is pointless); more specifically
			// pMutation<0.1/nPopulation such that mutations occur less than every 10
			// generations and hence scores can be assumed
			// to be homogeneous when the mutant arises.
			int skip = distrMutation.next();
			double wScoreTot = 0.0;
			int nPopTot = 0;
			// advance time and homogenize scores
			if (isMultispecies) {
				for (Population pop : species) {
					int nPop = pop.getNPopulation();
					nPopTot += nPop;
					wScoreTot += pop.sumFitness * pop.getSpeciesUpdateRate();
				}
				double realtimeIncr = (wScoreTot <= 1e-8 ? Double.POSITIVE_INFINITY : skip / wScoreTot);
				double gincr = skip / (double) nPopTot;
				realtime += realtimeIncr;
				generation += gincr;
				for (Population pop : species) {
					pop.realtime = realtime;
					pop.generation = generation;
					pop.resetStrategies();
				}
			} else {
				Population pop = (Population) this;
				realtime += skip / (pop.sumFitness * pop.speciesUpdateRate);
				generation += skip / (double) pop.nPopulation;
				pop.resetStrategies();
			}
			update();
			// communicate update
			engine.fireModelChanged();
			// determine species and introduce mutant
			Population focalPop = pickFocalSpecies();
			if (isMultispecies) {
				// recalculate total weighted scores after reset
				wScoreTot = 0.0;
				for (Population pop : species)
					wScoreTot += pop.sumFitness * pop.getSpeciesUpdateRate();
				double realtimeIncr = (wScoreTot <= 1e-8 ? Double.POSITIVE_INFINITY
						: focalPop.sumFitness * focalPop.getSpeciesUpdateRate() / (wScoreTot * wScoreTot));
				double gincr = 1.0 / nPopTot;
				realtime += realtimeIncr;
				generation += gincr;
				for (Population pop : species) {
					pop.realtime = realtime;
					pop.generation = generation;
				}
			} else {
				realtime += 1.0 / (focalPop.sumFitness * focalPop.speciesUpdateRate);
				generation += 1.0 / focalPop.nPopulation;
			}
			int rand = random0n(focalPop.nPopulation);
			focalPop.mutateStrategyAt(rand, false);
			if (focalPop.adjustScores)
				focalPop.adjustGameScoresAt(rand);
			else {
				focalPop.resetScoreAt(rand);
				focalPop.commitStrategyAt(rand);
				focalPop.playGameAt(rand);
			}
			return true;
		}
		double diff = nGenerations - generation;
		if (Math.abs(diff)<1e-10 && !nGenerationsHit) {
			nGenerationsHit = true;
			return false;
		}
		double step = Math.min(reportFreq, diff > 0.0 ? diff : reportFreq);
		double deltat = next(step);
		// converged if deltat<0
		if (deltat < 0.0) 
			return false;
		if (Math.abs(generation - nGenerations)<1e-10 && !nGenerationsHit) {
			nGenerationsHit = true;
			return false;
		}
		return true;
	}

	/**
	 * {@inheritDoc}
	 * 
	 * @return time increment (in generations); negative increment if
	 *         converged/absorbed (individual based simulations cannot reverse time)
	 */
	public double next(double stepDt) {
		if (isSynchronous) {
			// reset strategies (colors)
			int nPopTot = 0;
			double wScoreTot = 0.0;
			for (Population pop : species) {
				pop.resetStrategies();
				nPopTot += pop.getPopulationSize();
				wScoreTot += pop.sumFitness * pop.getSpeciesUpdateRate();
			}
			// nUpdates measured in generations
			int nUpdates = Math.max(1, (int) Math.floor(stepDt));
//XXX how to take update rates of species into account? necessary?
//TODO: implement Wright-Fisher update
//			switch( populationUpdateType ) {
//				case POPULATION_UPDATE_SYNCHRONOUS:
			for (int f = 0; f < nUpdates; f++) {
				// advance time and update strategies
				// nPopTot or wPopTot? what to do if update rates differ?
				double realtimeIncr = (wScoreTot <= 1e-8 ? Double.POSITIVE_INFINITY : nPopTot / wScoreTot);
				wScoreTot = 0.0;
				realtime += realtimeIncr;
				generation++;
				for (Population pop : species) {
					pop.realtime = realtime;
					pop.generation = generation;
					pop.prepareStrategies();
					int nPop = pop.getNPopulation();
					for (int n = 0; n < nPop; n++)
						pop.updatePlayerAt(n);
					nPopTot += pop.getPopulationSize();
				}
				// commit strategies and reset scores
				for (Population pop : species) {
					pop.commitStrategies(); // also check homogeneity
					//TODO: review migration - should be an independent event, independent of population update
					// NOTE: should time advance? e.g. based on number of mutants
					pop.doSyncMigration(); // do migration
					// all scores must be reset before we can re-calculate them
					pop.resetScores();
				}
				// calculate new scores (requires that all strategies are committed and reset)
				boolean stopRequested = true;
				for (Population pop : species) {
					pop.updateScores();
					stopRequested &= pop.hasConverged();
					wScoreTot += pop.sumFitness * pop.getSpeciesUpdateRate();
				}
				if (stopRequested) {
					nUpdates = f + 1;
					break;
				}
			}
//				break;
//			case POPULATION_UPDATE_WRIGHT_FISHER:
//				break;
//			default:		// should never get here
//				throw new Error("modelNext: unknown synchronous population update ("+(char)populationUpdateType+")");
//		}
//debugCheck("modelNext (update, sync)");
			return nUpdates;
		}

		// asynchronous population update - update one individual at a time
		double wPopTot = 0.0, wScoreTot = 0.0;
		// reset strategies (colors)
		for (Population pop : species) {
			pop.resetStrategies();
			double rate = pop.getSpeciesUpdateRate();
			// determine generation time and real time increments
			// NOTE: generation time increments based on maximum population sizes and do not
			// take potentially fluctuating sizes into account (relevant for ecological
			// settings)
			wPopTot += pop.getPopulationSize() * rate;
			double sum = pop.sumFitness;
			if (wScoreTot>=0.0 && sum <= 1e-8) {
				wScoreTot = -1.0;
				continue;
			}
			wScoreTot += sum * rate;
		}
		double gincr = 1.0 / wPopTot;
		// round nUpdates up while trying to avoid rounding errors.
		// process at least one update.
		// note: nUpdates can exceed Integer.MAX_VALUE (notably for large populations, long relaxation times and high 
		//		 interaction rates of species); switching to long is not an option because of GWT
//XXX note: gincr is not constant if population size can vary...
		double dUpdates = Math.max(1.0, Math.ceil(stepDt / gincr - 1e-8));
		double stepDone = 0.0;
		double gStart = generation;
		while (dUpdates>=1.0) {
			boolean converged = false;
			double stepSize = 0.0;
			int nUpdates = Math.min((int)dUpdates, 1000000000);	// 1e9 about half of Integer.MAX_VALUE (2.1e9)
			for (int n = 0; n < nUpdates; n++) {
				// update event
				double rincr = (wScoreTot<0.0 ? 0.0 : 1.0 / (wScoreTot * wScoreTot));
				// advance time
				generation += gincr;
				realtime += rincr / pickFocalSpecies().step();
				realtime = wScoreTot<0.0 ? Double.POSITIVE_INFINITY : realtime;
				wPopTot = wScoreTot = 0.0;
				converged = true;
				for (Population pop : species) {
					pop.realtime = realtime;
					pop.generation = generation;
					converged &= pop.hasConverged();
					// update generation time and real time increments
					double rate = pop.getSpeciesUpdateRate();
					wPopTot += pop.getPopulationSize() * rate;
					double sum = pop.sumFitness;
					if (wScoreTot>=0.0 && sum <= 1e-8) {
						wScoreTot = -1.0;
						continue;
					}
					wScoreTot += sum * rate;
				}
				if (converged)
					break;
				gincr = 1.0 / wPopTot;
			}
//XXX note: gincr is not constant if population size can vary...
			stepSize = nUpdates*gincr;
			stepDone += Math.abs(stepSize);
			generation = gStart + Math.abs(stepDone);
			if (converged)
				return -stepDone;
			dUpdates = (stepDt-stepDone) / gincr;
		}
		return stepDt;
	}

	/**
	 * Pick focal population according to the selected scheme. 
	 * 
	 * @return focal population
	 * 
	 * @see SpeciesUpdateType
	 */
	public Population pickFocalSpecies() {
		if (!isMultispecies)
			return (Population) this;
		switch (speciesUpdateType) {
			case FITNESS:
				double wScoreTot = 0.0;
				for (Population pop : species)
					wScoreTot += pop.sumFitness * pop.getSpeciesUpdateRate();
				return pickFocalSpeciesFitness(wScoreTot);
			case SIZE:
				double wPopTot = 0.0;
				for (Population pop : species)
					wPopTot += pop.getPopulationSize() * pop.getSpeciesUpdateRate();
				return pickFocalSpeciesSize(wPopTot);
			case TURNS:
				return pickFocalSpeciesTurns();
		}
		throw new Error("unknown species update type!");
	}

	/**
	 * Return population to update with probability proportional to size of
	 * population and update rate
	 * 
	 * @param wPopTot
	 * @return focal population
	 */
	private Population pickFocalSpeciesSize(double wPopTot) {
		if (getNSpecies() == 1)
			return (Population) this;
		double rand = random01() * wPopTot;
		for (Population pop : species) {
			rand -= pop.getPopulationSize() * pop.getSpeciesUpdateRate();
			if (rand < 0.0)
				return pop;
		}
		// should not get here
		return null;
	}

	/**
	 * Return population to update with probability proportional to fitness of
	 * population and update rate
	 * 
	 * @param wScoreTot
	 * @return focal population
	 */
	private Population pickFocalSpeciesFitness(double wScoreTot) {
		if (getNSpecies() == 1)
			return (Population) this;
		double rand = random01() * wScoreTot;
		for (Population pop : species) {
			rand -= pop.sumFitness * pop.getSpeciesUpdateRate();
			if (rand < 0.0)
				return pop;
		}
		// should not get here
		return null;
	}

	/**
	 * Index of next species to update for turn-based-selection; simply cycles
	 * through species array
	 */
	private int nextSpeciesIdx = -1;

	/**
	 * Return population to update one after another in a sequential manner.
	 * 
	 * @return focal population
	 */
	private Population pickFocalSpeciesTurns() {
		int nSpecies = getNSpecies();
		if (nSpecies == 1)
			return (Population) this;
		nextSpeciesIdx = (nextSpeciesIdx + 1) % nSpecies;
		return species.get(nextSpeciesIdx);
	}

	@Override
	public void update() {
		// all populations need to be updated/reset before scores can be calculated for
		// inter-species interactions
		for (Population pop : species)
			pop.resetScores();
		for (Population pop : species)
			pop.updateScores();
	}

// work in progress - kaleidoscopes, halfplanes as well as reaction-diffusion systems can use this but they have disjoint set of initialization types.
//	int initType = RANDOM;
//
//	public static final int RANDOM = 0;
//	public static final int KALEIDOSCOPE = 1;
//interferes with strategy in Moran
//	public static final int MUTANT = 2;

//should check the validity of the requested type!
	public boolean setInitType(int type) {
//		initType = type;
		// currently pde (and sde/ode) is undefined for continuous strategies
//		if (pde != null)
//			return pde.setInitType(type);
		return true;
	}

	public int getInitType() {
		// currently pde (and sde/ode) is undefined for continuous strategies
//		if (pde != null)
//			return pde.getInitType();
		return -1;
//		return initType;
	}
// end work in progress

	/**
	 * Set report frequency, i.e. number of updates in one step (see
	 * {@link #modelNext()} measured in generations.
	 * 
	 * @param aValue new number of generation between subsequent reports.
	 */
	public void setReportFreq(double aValue) {
		reportFreq = Math.max(0.0, aValue);
	}

	/**
	 * @return report frequency
	 */
	public double getReportFreq() {
		return reportFreq;
//		if( populationUpdateType==POPULATION_UPDATE_SYNCHRONOUS ) return Math.max(1, (int)Math.floor(reportFreq));
//		return Math.max(1.0/nPopulation, reportFreq);
	}

	/**
	 * Set mutation probability in one update to <code>aValue</code>. mutations are
	 * disabled for negative values.
	 * 
	 * @param aValue new probability of a mutation.
	 */
	public void setMutationProb(double aValue) {
		if (aValue >= 0.0) {
			pMutation = Math.max(Math.min(aValue, 1.0), 0.0);
			return;
		}
		pMutation = -1.0;
	}

	/**
	 * @return mutation probability
	 */
	public double getMutationProb() {
		return pMutation;
	}

	/**
	 * Command line option to set verbosity level of logging.
	 */
	protected final CLOption cloVerbose = new CLOption("verbose", CLOption.Argument.REQUIRED, "info",
			"--verbose <l>  level of verbosity with l one of\n      all, debug/finest, finer, fine, config,\n      info, warning, error, or none",
			new CLODelegate() {
				@Override
				public boolean parse(String arg) {
					String larg = arg.toLowerCase();
					if ("all".startsWith(larg)) {
						logger.setLevel(Level.ALL);
						return true;
					}
					if ("debug".startsWith(larg)) {
						logger.setLevel(Level.FINEST);
						return true;
					}
					if ("finest".startsWith(larg)) {
						logger.setLevel(Level.FINEST);
						return true;
					}
					if ("finer".startsWith(larg)) {
						logger.setLevel(Level.FINER);
						return true;
					}
					if ("fine".startsWith(larg)) {
						logger.setLevel(Level.FINE);
						return true;
					}
					if ("debug".startsWith(larg)) {
						logger.setLevel(Level.CONFIG);
						return true;
					}
					if ("warning".startsWith(larg)) {
						logger.setLevel(Level.WARNING);
						return true;
					}
					if ("error".startsWith(larg) || "severe".startsWith(larg)) {
						logger.setLevel(Level.SEVERE);
						return true;
					}
					if ("none".startsWith(larg) || "off".startsWith(larg)) {
						logger.setLevel(Level.OFF);
						return true;
					}
					if ("info".startsWith(larg)) {
						logger.setLevel(Level.INFO);
						return true;
					}
					logger.warning("unknown verbosity '" + arg + "' - using '" + cloVerbose.getDefault() + "'.");
					return false;
				}
			});

	/**
	 * Command line option to set the type of initial configuration.
	 * <p>
	 * <strong>Note:</strong> currently only used for PDE models but should be extended to
	 * include, for example, kaleidoscopes, half-planes, or random distributions in
	 * simulations.
	 */
	protected final CLOption cloInitType = new CLOption("inittype", CLOption.Argument.REQUIRED, "0", // RD_INIT_RANDOM
			"--inittype <t>       type of initial configuration", new CLODelegate() {
				@Override
				public boolean parse(String arg) {
					if (setInitType(CLOParser.parseInteger(arg)))
						return true;
					logger.warning("inittype '" + arg + "' unknown - using '" + cloInitType.getDefault() + "'");
					return false;
				}

				@Override
				public void report(PrintStream output) {
					if (engine.getModel().isModelType(Model.Type.PDE))
						output.println("# inittype:             " + getInitType());
				}
			});

	/**
	 * Command line option to set the method for selecting which species to update
	 * (see {@link SpeciesUpdateType}).
	 */
	protected final CLOption cloSpeciesUpdateType = new CLOption("speciesupdate", CLOption.Argument.REQUIRED,
			SpeciesUpdateType.SIZE.getKey(),
			"--speciesupdate <u>  species update type",
			new CLODelegate() {
				@Override
				public boolean parse(String arg) {
					SpeciesUpdateType sut = SpeciesUpdateType.parse(arg);
					if (sut == null) {
						logger.warning(
								"species update '" + arg + "' unknown - using '" + cloSpeciesUpdateType.getDefault() + "'");
						return false;
					}
					setSpeciesUpdateType(sut);
					return true;
				}

				@Override
				public void report(PrintStream output) {
					if (species.size() > 1)
						output.println("# speciesupdate:        " + getSpeciesUpdateType());
				}
			});

	/**
	 * Command line option to set the rate for updating each population. Only
	 * relevant for multi-species interactions.
	 */
	protected final CLOption cloSpeciesUpdateRate = new CLOption("speciesupdaterate", CLOption.Argument.REQUIRED, "1",
			new CLODelegate() {
				@Override
				public boolean parse(String arg) {
					return parseSpeciesUpdateRate(arg);
				}

				@Override
				public void report(PrintStream output) {
					if (getNSpecies() <= 1)
						return;
					for (Population pop : species) {
						output.println("# speciesupdaterate:    "
								+ Formatter.format(pop.getSpeciesUpdateRate(), 4) + " (" + pop.getName() + ")");
					}
				}

				@Override
				public String getDescription() {
					String descr = "";
					int nSpecies = species.size();
					switch (nSpecies) {
						case 1:
							// not applicable
							return null;
						case 2:
							descr = "--speciesupdaterate <r0:r1> update rates of population i, with\n";
							break;
						case 3:
							descr = "--speciesupdaterate <r0:r1:r2> update rates of population i, with\n";
							break;
						default:
							descr = "--speciesupdaterate <r0:...:r" + nSpecies + "> update rates of population i, with\n";
					}
					for (int i = 0; i < nSpecies; i++)
						descr += "            r" + i + ": " + species.get(i).getName() + "\n";
					descr += "      (loops through update rates)";
					return descr;
				}
			});

	public final CLOption cloGeometry = new CLOption("geometry", 'G', CLOption.Argument.REQUIRED, "M", null,
			new CLODelegate() {
		@Override
		public boolean parse(String arg) {
			// if both --geominter and --geomrepro are specified they override --geometry
			if( cloGeometryInteraction.isSet() && cloGeometryReproduction.isSet() ) return true;
			return parseGeometry(arg);
		}
		@Override
		public void report(PrintStream output) {
//Type modelType = engine.getModel().getModelType();
//			switch( modelType ) {
//				case PDE:
//// inter-species DEs not yet implemented
//					Geometry geo = pde.getGeometry();
//					output.println("# pde geometry:         "+geo.population.cloGeometry.getDescriptionKey(geo.geometry));
//					geo.printParams(output);
//					break;
//				case IBS:
					for( Population pop : species ) {
						Geometry intergeo = pop.getInteractionGeometry();
						if( intergeo.interReproSame ) {
							output.println("# geometry:             "+pop.cloGeometry.getKey(intergeo.geometry).getTitle()+(isMultispecies?" ("+pop.getName()+")":""));
							intergeo.printParams(output);
						}
					}
//					break;
//				default:	
//			}
		}
		@Override
		public String getDescription() {
			// retrieve description
			Population pop = species.get(0);
			return (pop.getGeometry()==null?pop.getInteractionGeometry().usage():pop.getGeometry().usage());
		}    	
	});

	protected final CLOption cloGeometryInteraction = new CLOption("geominter", CLOption.Argument.REQUIRED, "M",
			"--geominter <>       interaction geometry (see --geometry)",
			new CLODelegate() {
		@Override
		public boolean parse(String arg) {
			// only act if option has been explicitly specified - otherwise cloGeometry will take care of this
			if( !cloGeometryInteraction.isSet() ) return true;
			return parseInteractionGeometry(arg);
		}
		@Override
		public void report(PrintStream output) {
			for( Population pop : species ) {
				Geometry intergeo = pop.getInteractionGeometry();
				// interaction geometry can be null for pde models
				if( intergeo==null || intergeo.interReproSame )
					continue;
				output.println("# interactiongeometry:  "+pop.cloGeometry.getDescriptionKey(intergeo.geometry)+(isMultispecies?" ("+pop.getName()+")":""));
				intergeo.printParams(output);
			}
		}
	});

	protected final CLOption cloGeometryReproduction = new CLOption("geomrepro", CLOption.Argument.REQUIRED, "M", 
			"--geomrepro <>       reproduction geometry (see --geometry)",
			new CLODelegate() {
		@Override
		public boolean parse(String arg) {
			// only act if option has been explicitly specified - otherwise cloGeometry will take care of this
			if( !cloGeometryReproduction.isSet() ) return true;
			return parseReproductionGeometry(arg);
		}
		@Override
		public void report(PrintStream output) {
			for( Population pop : species ) {
				Geometry reprogeo = pop.getReproductionGeometry();
				// reproduction geometry can be null for pde models
				if( reprogeo==null || reprogeo.interReproSame )
					continue;
				output.println("# reproductiongeometry: "+pop.cloGeometry.getDescriptionKey(reprogeo.geometry)+(isMultispecies?" ("+pop.getName()+")":""));
				reprogeo.printParams(output);
			}
		}
	});

	/**
	 * Command line option to set the number of generations after which to stop the
	 * model calculations. Model execution can be resumed afterwards.
	 */
	protected final CLOption cloGenerations = new CLOption("generations", 'g', CLOption.Argument.REQUIRED, "-1",
			"--generations, -g<g> halt execution after <g> MC steps", new CLODelegate() {
				@Override
				public boolean parse(String arg) {
					if (cloGenerations.isSet())
						nGenerations = CLOParser.parseDouble(arg);
					else
						nGenerations = -Double.MAX_VALUE;
					return true;
				}

				@Override
				public void report(PrintStream output) {
					if (nGenerations > 0)
						output.println("# generations:          " + Formatter.format(nGenerations, 4));
				}
			});

	/**
	 * Command line option to set the probability of mutations.
	 */
	protected final CLOption cloMutation = new CLOption("mutation", 'm', CLOption.Argument.REQUIRED, "-1", null,
			new CLODelegate() {
				@Override
				public boolean parse(String arg) {
					return parseMutationProb(arg);
				}

				@Override
				public void report(PrintStream output) {
					for( Population pop : species ) {
						double mut = pop.getMutationProb();
						if (mut > 0.0) {
							output.println("# mutation:             " + Formatter.formatSci(mut, 8)+(isMultispecies?" ("+pop.getName()+")":""));
							continue;
						}
						if (mut < 0.0) {
							output.println("# mutation:             none"+(isMultispecies?" ("+pop.getName()+")":""));
							continue;
						}
						output.println("# mutation:             0 (restricted to homogeneous populations)"+(isMultispecies?" ("+pop.getName()+")":""));
					}
				}

				@Override
				public String getDescription() {
					String descr = "";
					int nSpecies = species.size();
					switch (nSpecies) {
						case 1:
							return "--mutation, -m <m>  mutation probability";
						case 2:
							descr = "--mutation, -m <m0:m1>  mutation probability of population i, with\n";
							break;
						case 3:
							descr = "--mutation, -m <m0:m1:m2>  mutation probability of population i, with\n";
							break;
						default:
							descr = "--mutation, -m <m0:...:m" + nSpecies
									+ ">  mutation probability of population i, with\n";
					}
					for (int i = 0; i < nSpecies; i++)
						descr += "            n" + i + ": " + species.get(i).getName() + "\n";
					descr += "      (loops through mutation rates)";
					return descr;
				}
			});

	/**
	 * Command line option to request optimizations.
	 */
	protected final CLOption cloOptimize = new CLOption("optimize", '1', CLOption.Argument.NONE, "nooptimize",
			"--optimize, -1       optimize Moran processes (destroys time-scale)", new CLODelegate() {
				@Override
				public boolean parse(String arg) {
					boolean doOpt = cloOptimize.isSet();
//					for (Population pop : getSpecies()) {
//						pop.optimizeHomo = doOpt;
//						pop.optimizeMoran = doOpt;
//					}
					optimizeHomo = doOpt;
					optimizeMoran = doOpt;
					return true;
				}
				// note: Population reports optimizations
			});

	/**
	 * Command line option to set the number of generations between reports for
	 * {@link #modelNext()}.
	 */
	protected final CLOption cloReportInterval = new CLOption("reportfreq", CLOption.Argument.REQUIRED, "1",
			"--reportfreq <f>     report frequency in MC steps", new CLODelegate() {
				@Override
				public boolean parse(String arg) {
					setReportFreq(Double.parseDouble(arg));
					return true;
				}

				@Override
				public void report(PrintStream output) {
					output.println("# reportfreq:           " + Formatter.format(getReportFreq(), 4));
				}
			});

	/**
	 * {@inheritDoc}
	 * 
	 * Override this method in subclasses to add further command line options
	 * subclasses must make sure that they include a call to super.
	 * 
	 * @param parser
	 */
	@Override
	public void collectCLO(CLOParser parser) {
		// prepare command line options
		parser.addCLO(cloVerbose);
		if (!EvoLudo.isGWT)
			// default verbosity if running as java application is warning
			cloVerbose.setDefault("warning");
		parser.addCLO(cloGeometryInteraction);
		parser.addCLO(cloGeometryReproduction);
		parser.addCLO(cloGeometry);
		parser.addCLO(cloInitType);
// optimizations currently only available for DPopulation - add cloOptimize only for those
//		parser.addCLO(cloOptimize);
		// multi-species interactions
		if (getNSpecies() > 1) {
			// individual population update rates only meaningful for multiple species
			parser.addCLO(cloSpeciesUpdateRate);
			cloSpeciesUpdateType.addKeys(SpeciesUpdateType.values());
			parser.addCLO(cloSpeciesUpdateType);
		}
		parser.addCLO(cloGenerations);
		parser.addCLO(cloMutation);
		parser.addCLO(cloReportInterval);
	}

	/**
	 *
	 * @param arg
	 * @param species
	 * @return <code>true</code> if parsing successful
	 */
	public boolean parseSpeciesUpdateRate(String arg) {
		String[] speciesupdaterates = arg.split(CLOParser.SPECIES_DELIMITER);
		int n = 0;
		for( Population pop : getSpecies() ) {
			pop.setSpeciesUpdateRate(CLOParser.parseDouble(speciesupdaterates[n]));
			n = (n+1)%speciesupdaterates.length;
		}
		return true;
	}

	/**
	 * Helper method to parse the argument encoding the population structure (for a
	 * single or multiple populations). Whether this refers to the interaction
	 * geometry, the reproduction geometry or both, depends on whether either of
	 * them is explicitly set on the command line. Moreover, this can also refer to
	 * the geometry used for PDE models.
	 * 
	 * @param arg encoding population structure
	 * @return <code>true</code> if parsing successful
	 */
	public boolean parseGeometry(String arg) {
		String[] geomargs = arg.split(CLOParser.SPECIES_DELIMITER);
		boolean doReset = false;
		int n = 0;
		for (Population pop : getSpecies()) {
			Geometry geom = pop.createGeometry();
			doReset |= geom.parse(geomargs[n]);
			n = (n + 1) % geomargs.length;
		}
		engine.requiresReset(doReset);
		return true;
	}

	/**
	 * Helper method to parse the argument encoding the interaction geometry (for a
	 * single or multiple populations).
	 * 
	 * @param arg encoding interaction geometry
	 * @return <code>true</code> if parsing successful
	 */
	public boolean parseInteractionGeometry(String arg) {
		String[] geomargs = arg.split(CLOParser.SPECIES_DELIMITER);
		boolean doReset = false;
		int n = 0;
		for (Population pop : getSpecies()) {
			if (pop.getInteractionGeometry() == pop.getGeometry()) {
				// need to create a new, independent interaction geometry
				pop.interaction = null;
			}
			Geometry geom = pop.createInteractionGeometry();
			doReset |= geom.parse(geomargs[n]);
			n = (n + 1) % geomargs.length;
		}
		engine.requiresReset(doReset);
		return true;
	}

	/**
	 * Helper method to parse the argument encoding the reproduction geometry (for a
	 * single or multiple populations).
	 * 
	 * @param arg encoding reproduction geometry
	 * @return <code>true</code> if parsing successful
	 */
	public boolean parseReproductionGeometry(String arg) {
		String[] geomargs = arg.split(CLOParser.SPECIES_DELIMITER);
		boolean doReset = false;
		int n = 0;
		for (Population pop : getSpecies()) {
			if (pop.getReproductionGeometry() == pop.getGeometry()) {
				// need to create a new, independent reproduction geometry
				pop.reproduction = null;
			}
			Geometry geom = pop.createReproductionGeometry();
			doReset |= geom.parse(geomargs[n]);
			n = (n + 1) % geomargs.length;
		}
		engine.requiresReset(doReset);
		return true;
	}

	/**
	 * Helper method to parse the mutation rate for a single or multiple
	 * populations.
	 * 
	 * @param arg (vector of) mutation probabilities.
	 * @return <code>true</code> if parsing successful
	 */
	public boolean parseMutationProb(String arg) {
		String[] mutations = arg.split(CLOParser.SPECIES_DELIMITER);
		int n = 0;
		try {
			for (Population pop : getSpecies()) {
				double pMut = Double.parseDouble(mutations[n]);
				pop.setMutationProb(pMut);
				n = (n + 1) % mutations.length;
			}
		} catch (NumberFormatException nfe) {
			for (Population pop : getSpecies())
				pop.setMutationProb(-1.0);
			logger.warning("mutation probabilities '" + arg + "' invalid - disabling mutations.");
			return false;
		}
		return true;
	}

	/**
	 * GWT has an aversion to clone()ing - provide alternatives.
	 * 
	 * @param orig boolean array to clone.
	 * @return clone of boolean array <code>orig</code>.
	 */
	protected static boolean[] clone(boolean[] orig) {
		int len = orig.length;
		boolean[] clone = new boolean[len];
		System.arraycopy(orig, 0, clone, 0, len);
		return clone;
	}

	/**
	 * GWT has an aversion to clone()ing - provide alternatives.
	 * 
	 * @param orig int array to clone.
	 * @return clone of int array <code>orig</code>.
	 */
	protected static int[] clone(int[] orig) {
		int len = orig.length;
		int[] clone = new int[len];
		System.arraycopy(orig, 0, clone, 0, len);
		return clone;
	}

	/**
	 * GWT has an aversion to clone()ing - provide alternatives.
	 * 
	 * @param orig double array to clone.
	 * @return clone of double array <code>orig</code>.
	 */
	protected static double[] clone(double[] orig) {
		int len = orig.length;
		double[] clone = new double[len];
		System.arraycopy(orig, 0, clone, 0, len);
		return clone;
	}

	/**
	 * GWT has an aversion to clone()ing - provide alternatives.
	 * 
	 * @param orig two dimensional array (matrix) to clone.
	 * @return clone of matrix <code>orig</code>.
	 */
	protected static double[][] clone(double[][] orig) {
		int len = orig.length;
		double[][] clone = new double[len][];
		for (int i = 0; i < len; i++)
			clone[i] = clone(orig[i]);
		return clone;
	}

	/**
	 * logger for keeping track of events and issues.
	 */
	protected Logger logger;

	/**
	 *
	 * @param msg
	 */
//XXX most likely progress should not be logged at all but rather reported to console - does not make sense with GUI.
	public void logProgress(String msg) {
		// abuse of Level.CONFIG for progress reports (GWT does not support custom
		// levels)
		logger.config(msg);
	}

	/**
	 * Random number generator is maintained by EvoLudo engine. This is just
	 * a convenience variable.
	 */
	protected RNGDistribution rng;


	/**
	 * Set random seed
	 *
	 * @param s seed for random number generator
	 */
	public void srandom(long s) {
		rng.setRNGSeed(s);
	}

	/**
	 * random integer number from interval <code>[0, n]</code>.
	 *
	 * @param n upper limit of interval (inclusive)
	 * @return random integer number in <code>[0, n]</code>.
	 */
	public int random0N(int n) {
		return rng.random0N(n);
	}

	/**
	 * random integer number from interval <code>[0, n)</code>.
	 *
	 * @param n upper limit of interval (exclusive)
	 * @return random integer number in <code>[0, n)</code>.
	 */
	public int random0n(int n) {
		return rng.random0n(n);
	}

	/**
	 * Random number from interval [0, 1) with 32bit resolution. This is the
	 * default.
	 *
	 * @return random number in <code>[0, 1)</code>.
	 */
	public double random01() {
		return rng.random01();
	}

	/**
	 * Random number from interval [0, 1) with maximum 53bit resolution.
	 * <p>
	 * <strong>Note:</strong> takes twice as long as regular precision.
	 *
	 * @return random number in <code>[0, 1)</code>.
	 */
	public double random01d() {
		return rng.random01d();
	}

	/**
	 * Generate Gaussian (normal) distributed random number.
	 * 
	 * @param mean of Gaussian distribution
	 * @param sdev (standard deviation) of Gaussian distribution
	 * @return Gaussian random number
	 */
	public double randomGaussian(double mean, double sdev) {
		return mean + sdev * rng.nextGaussian();
	}

	/**
	 * Generate binomially distributed random number.
	 * 
	 * @param p probability of success
	 * @param n number of trials
	 * @return number of successes
	 */
	public int nextBinomial(double p, int n) {
		if (n == 0)
			return 0;
		if (p > 1.0 - 1e-8)
			return 0;

		// check if gaussian approximation is suitable
		double np = n * p;
		if (np / (1.0 - p) > 9.0 && n * (1.0 - p) / p > 9.0)
			return (int) Math.floor(randomGaussian(np + 0.5, Math.sqrt(np * (1.0 - p))));

		double uRand = random01();
		double pi = Combinatorics.pow(1.0 - p, n);
		double f = p / (1.0 - p);
		double sum = 0.0;

		for (int i = 0; i <= n; i++) {
			sum += pi * Combinatorics.combinations(n, i);
			if (uRand <= sum)
				return i;
			pi *= f;
		}
		logger.warning(
				"What the heck are you doing here!!! (rand: " + uRand + ", p: " + p + ", n: " + n + " -> " + sum + ")");
		return -1;
	}

	/**
	 * Entry point for JRE simulations. Must be overridden in simulation subclasses.
	 */
	public void exec() {
		throw new Error("Executable not implemented!");
	}
}
